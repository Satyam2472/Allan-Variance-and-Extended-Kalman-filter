# -*- coding: utf-8 -*-
"""Extended Kalman Filter

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/139nF7R6FfbQNEw8VCpjgiNI3N7K5X0oE
"""

import numpy as np
import pandas as pd
import math as m

data = pd.read_csv(r'/content/Expt_Data_Recordings_16-04-2019 (1).csv')
data.head()

# Earth's rotation rate in deg/sec
ext_kal_fil = []
omega = 0.004178

# Supress scientific notation when printing NumPy arrays
np.set_printoptions(precision=3,suppress=True)
 
# A matrix
# 3x3 matrix -> number of states x number of states matrix
# Expresses how the state of the system [x,y,z] changes 
# from k-1 to k when no control command is executed.

"""For this case, A is the identity matrix.
   A is sometimes F in the literature."""
A_k_minus_1 = np.array([[1.0,  0,   0],
                        [  0,1.0,   0],
                        [  0,  0, 1.0]])
 
#This is a vector with the number of elements equal to the number of states
process_noise_v_k_minus_1 = np.array([0.01,0.01,0.003])
     
# State model noise covariance matrix Q_k
# When Q is large, the Kalman Filter tracks large changes in 
# the sensor measurements more closely than for smaller Q.
"""# Q is a square matrix that has the same number of rows as states."""
Q_k = np.array([[1.0,   0,   0],
                [  0, 1.0,   0],
                [  0,   0, 1.0]])
                 
# Measurement matrix H_k
# Used to convert the predicted state estimate at time k
# into predicted sensor measurements at time k.
"""# In this case, H will be the identity matrix since the 
# estimated state maps directly to state measurements from the""" 
"""# H has the same number of rows as sensor measurements
# and same number of columns as states."""
H_k = np.array([[1.0,  0,   0],
                [  0, 1.0,   0],
                [  0,  0, 1.0]])
                         
# Sensor measurement noise covariance matrix R_k
"""# Has the same number of rows and columns as sensor measurements."""
# If we are sure about the measurements, R will be near zero.
R_k = np.array([[1.0,   0,    0],
                [  0, 1.0,    0],
                [  0,    0, 1.0]]) 

"""# Sensor noise. This is a vector with the
# number of elements equal to the number of sensor measurements."""
sensor_noise_w_k = np.array([0.007,0.007,0.004])
 
def getB(fi, chi):
    """
    Calculates and returns the B matrix
    3x2 matix -> number of states x number of control inputs
    The control inputs are the latitude (φ) and the
    angle between the initial direction 
    of the gyroscope sensitive axis and true North (ψ).
    [φ,ψ]
    Expresses how the state of the system [x,y,z] changes
    from k-1 to k due to the control commands (i.e. control input).
    """
    B = np.array([  [m.cos(fi)*m.cos(chi)*omega, 0],
                    [m.cos(fi)*m.cos(chi)*omega*(-1), 0],
                    [0, 0]])
    return B
 
def ekf(z_k_observation_vector, state_estimate_k_minus_1, 
        control_vector_k_minus_1, P_k_minus_1, dk):
    """
    Extended Kalman Filter. Fuses noisy sensor measurement to 
    create an optimal estimate of the state.
         
    INPUT
        :param z_k_observation_vector.
        :param state_estimate_k_minus_1 The state estimate at time k-1.
        :param control_vector_k_minus_1 The control vector applied at time k-1.
        :param P_k_minus_1 The state covariance matrix estimate at time k-1
        :param dk Time interval in seconds
             
    OUTPUT
        :return state_estimate_k near-optimal state estimate at time k  
        :return P_k state covariance_estimate for time k               
    """
    ######################### Predict #############################
    # Predict the state estimate at time k based on the state 
    # estimate at time k-1 and the control input applied at time k-1.
    global state_estimate_k
    state_estimate_k = A_k_minus_1 @ (
            state_estimate_k_minus_1) + (
            getB(state_estimate_k_minus_1[2],dk)) @ (
            control_vector_k_minus_1) + (
            process_noise_v_k_minus_1)
             
    print(f'State Estimate Before EKF={state_estimate_k}')
             
    # Predict the state covariance estimate based on the previous
    # covariance and some noise
    P_k = A_k_minus_1 @ P_k_minus_1 @ A_k_minus_1.T + (
            Q_k)
         
    ################### Update (Correct) ##########################
    # Calculate the difference between the actual sensor measurements
    # at time k minus what the measurement model predicted 
    # the sensor measurements would be for the current timestep k.
    measurement_residual_y_k = z_k_observation_vector - (
            (H_k @ state_estimate_k) + (
            sensor_noise_w_k))
 
    print(f'Observation={z_k_observation_vector}')
             
    # Calculate the measurement residual covariance
    S_k = H_k @ P_k @ H_k.T + R_k
         
    # Calculate the near-optimal Kalman gain
    # We use pseudoinverse since some of the matrices might be
    # non-square or singular.
    K_k = P_k @ H_k.T @ np.linalg.pinv(S_k)
         
    # Calculate an updated state estimate for time k
    state_estimate_k = state_estimate_k + (K_k @ measurement_residual_y_k)
    
    
    ext_kal_fil.append(state_estimate_k)

    # Update the state covariance estimate for time k
    P_k = P_k - (K_k @ H_k @ P_k)


    # Print the best (near-optimal) estimate of the current state of the robot
    print(f'State Estimate After EKF={state_estimate_k}')
 
    # Return the updated state and covariance estimates
    return state_estimate_k, P_k
     
def main():
    
    # We start at time k=1
    k = 1
     
    # Time interval in seconds
    dk = 1
 
    # Create a list of sensor observations at successive timesteps
    # Each list within z_k is an observation vector.
    global x, y, z
    x = data["GyX"]
    y = data["GyY"]
    z = data["GyZ"]
    Z = np.array([x, y, z])
    z_k = Z.T
                     
    # The estimated state vector at time k-1 in the global reference frame.
    state_estimate_k_minus_1 = np.array([0.0,0.0,0.0])
     

    control_vector_k_minus_1 = np.array([6.0,6.5])
     
    # State covariance matrix P_k_minus_1
    P_k_minus_1 = np.array([[0.1,  0,   0],
                            [  0,0.1,   0],
                            [  0,  0, 0.1]])
                             
    # Start at k=1 and go through each of the 13448 sensor observations, 
    # one at a time. 
    # We stop right after timestep k=13448 (i.e. the last sensor observation)
    for k, obs_vector_z_k in enumerate(z_k,start=1):
     
        # Print the current timestep
        print(f'Timestep k={k}')  
         
        # Run the Extended Kalman Filter and store the 
        # near-optimal state and covariance estimates
        optimal_state_estimate_k, covariance_estimate_k = ekf(
            obs_vector_z_k, # Most recent sensor measurement
            state_estimate_k_minus_1, # Our most recent estimate of the state
            control_vector_k_minus_1, # Our most recent control input
            P_k_minus_1, # Our most recent state covariance matrix
            dk) # Time interval
         
        # Get ready for the next timestep by updating the variable values
        state_estimate_k_minus_1 = optimal_state_estimate_k
        P_k_minus_1 = covariance_estimate_k
         
        # Print a blank line
        print()
 
# Program starts running here with the main method  
main()

import matplotlib.pyplot as plt

# This is the plot of Extended Kalman Filter

plt.plot(x)
plt.title("Original reading of X component")
plt.show()

X = list()
pd.DataFrame(ext_kal_fil)
for i in range(1, len(ext_kal_fil)):
    X.append(ext_kal_fil[i][0])

# a = max(X)
# b = min(X)

# interval_X = a - b
# mid = (a + b)/2
# for i in range(len(X)):
#     if (abs(X[i]) > mid ):
#         X[i] = X[i]/mid

plt.plot(X)
plt.title("After applying Extended Kalman Filter on X component")
plt.show()

import matplotlib.pyplot as plt

# This is the plot of Extended Kalman Filter

plt.plot(y)
plt.title("Original reading of Y component")
plt.show()

Y = list()
pd.DataFrame(ext_kal_fil)
for i in range(1, len(ext_kal_fil)):
    Y.append(ext_kal_fil[i][1])

c = max(Y)
d = min(Y)

interval = c - d
for i in range(len(Y)):
    Y[i] = Y[i]/interval

plt.plot(Y)
plt.title("After applying Extended Kalman Filter on Y component")
plt.show()

